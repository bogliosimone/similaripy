{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-similaripys-documentation","title":"Welcome to SimilariPy\u2019s documentation!","text":"<p>SimilariPy is a Python package that provides high-performance KNN similarity and normalization functions, optimized for sparse matrices.</p>"},{"location":"#why-similaripy","title":"\ud83d\udd25 Why SimilariPy?","text":"<ul> <li>Fast: powered by Cython and OpenMP for fast parallel execution</li> <li>Sparse matrix focus: optimized for Scipy CSR/COO formats</li> <li>Wide similarity coverage: Dot Product, Cosine, Tversky, P3\u03b1, RP3\u03b2, and more</li> <li>Flexible normalization: includes L1, L2, TF-IDF, BM25, BM25+</li> </ul>"},{"location":"#guide","title":"\ud83d\udcda Guide","text":"<ul> <li>Installation instructions</li> <li>Quickstart guide</li> <li>Quick reference to similarity functions</li> <li>Quick reference to normalization functions</li> <li>Full API documentation</li> </ul>"},{"location":"guide/","title":"\ud83d\udccc Getting Started","text":"<p>SimilariPy provides high-performance KNN similarity functions in Python, optimized for sparse matrices.</p> <p>Primarily designed for Recommender Systems and Information Retrieval (IR) tasks, but can be applied to other domains as well.</p> <p>The package also includes a set of normalization functions useful for pre-processing data in-place before the similarity computation.</p>"},{"location":"guide/#similarity-functions","title":"Similarity Functions","text":"<p>SimilariPy provides a range of high-performance similarity functions for sparse matrices. All functions are multi-threaded and implemented in Cython + OpenMP for fast parallel computation on CSR matrixes.</p>"},{"location":"guide/#core","title":"Core","text":"<ul> <li>Dot Product \u2013 Simple raw inner product between vectors.</li> <li>Cosine \u2013 Normalized dot product based on L2 norm.</li> <li>Asymmetric Cosine \u2013 Skewed cosine similarity using an <code>alpha</code> parameter.</li> <li>Jaccard, Dice, Tversky \u2013 Set-based generalized similarities.</li> </ul>"},{"location":"guide/#graph-based","title":"Graph-Based","text":"<ul> <li>P3\u03b1 \u2013 Graph-based similarity computed through random walk propagation with exponentiation.</li> <li>RP3\u03b2 \u2013 Similar to P3\u03b1 but includes popularity penalization using a <code>beta</code> parameter.</li> </ul>"},{"location":"guide/#advanced","title":"Advanced","text":"<ul> <li>S-Plus \u2013 A hybrid model combining Tversky and Cosine components, with full control over weights and smoothing.</li> </ul>"},{"location":"guide/#normalization-functions","title":"Normalization Functions","text":"<p>SimilariPy provides a suite of normalization functions for sparse matrix pre-processing. All functions are implemented in Cython and can operate in-place on CSR matrixes for maximum performance and memory efficiency.</p> <ul> <li>L1, L2 \u2013 Applies row- or column-wise normalization.</li> <li>TF-IDF \u2013 Computes TF-IDF weighting with customizable term-frequency and IDF modes.</li> <li>BM25 \u2013 Applies classic BM25 weighting used in information retrieval.</li> <li>BM25+ \u2013 Variant of BM25 with additive smoothing for low-frequency terms.</li> </ul>"},{"location":"guide/#example","title":"Example","text":"<p>Here\u2019s a minimal example to get you up and running with SimilariPy:</p> <pre><code>import similaripy as sim\nimport scipy.sparse as sps\n\n# Create a random User-Rating Matrix (URM)\nurm = sps.random(1000, 2000, density=0.025)\n\n# Normalize the URM using BM25\nurm = sim.normalization.bm25(urm)\n\n# Train an item-item cosine similarity model\nsimilarity_matrix = sim.cosine(urm.T, k=50)\n\n# Compute recommendations for user 1, 14, 8 \n# filtering out already-seen items\nrecommendations = sim.dot_product(\n    urm,\n    similarity_matrix.T,\n    k=100,\n    target_rows=[1, 14, 8],\n    filter_cols=urm\n)\n</code></pre> <p>Tips:</p> <ul> <li><code>urm.T</code> is used to switch from user-item to item-user when training the similarity model.</li> <li>You can use <code>bm25plus</code>, <code>tfidf</code>, or <code>normalize</code> for different pre-processing strategies.</li> <li>All operations are multithreaded and scale with available CPU cores.</li> </ul>"},{"location":"installation/","title":"\ud83d\udce6 Installation","text":""},{"location":"installation/#installation_1","title":"Installation","text":"<p>SimilariPy can be installed from PyPI with:</p> <pre><code>pip install similaripy\n</code></pre>"},{"location":"installation/#gcc-compiler-required","title":"GCC Compiler - Required","text":"<p>To install the package and compile the Cython code, a GCC-compatible compiler with OpenMP is required.</p>"},{"location":"installation/#ubuntu-debian","title":"Ubuntu / Debian","text":"<p>Install the official dev-tools:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential\n</code></pre>"},{"location":"installation/#macos-intel-apple-silicon","title":"MacOS (Intel &amp; Apple Silicon)","text":"<p>Install GCC with homebrew:</p> <pre><code>brew install gcc\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>Install the official Visual C++ Build Tools.</p> <p>\u26a0\ufe0f On Windows, use the default format_output='coo' in all similarity functions, as 'csr' is currently not supported.</p>"},{"location":"installation/#optional-optimization-intel-mkl-for-intel-cpus","title":"Optional Optimization: Intel MKL for Intel CPUs","text":"<p>For Intel CPUs, using SciPy/Numpy with MKL (Math Kernel Library) is highly recommended for best performance. The easiest way to achieve this is to install them via Anaconda.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"Package Version numpy &gt;= 1.21 scipy &gt;= 1.10.1 tqdm &gt;= 4.65.2"},{"location":"normalization/","title":"\ud83e\uddee Normalization Functions","text":"<p>SimilariPy includes several normalization functions designed for sparse matrix pre-processing. All functions are implemented in Cython and support in-place operation for memory efficiency.</p>"},{"location":"normalization/#normalizations","title":"Normalizations","text":"Function Description <code>normalize(X, norm='l2')</code> Standard row or column-wise normalization. Supports <code>'l1'</code>, <code>'l2'</code>, and <code>'max'</code>. <code>tfidf(X, tf_mode='sqrt', idf_mode='smooth')</code> TF-IDF weighting with customizable term-frequency and inverse-document-frequency modes. <code>bm25(X, k1=1.2, b=0.75)</code> BM25 weighting, a standard IR normalization used for relevance scoring. <code>bm25plus(X, k1=1.2, b=0.75, delta=1.0)</code> BM25+ variant with an additional smoothing <code>delta</code> parameter."},{"location":"normalization/#common-parameters","title":"Common Parameters","text":"<p>All normalization functions in SimilariPy share the following parameters:</p> Parameter Description <code>axis</code> <code>1</code> for row-wise (default), <code>0</code> for column-wise normalization. <code>inplace</code> If <code>True</code>, modifies the input matrix in-place. <code>logbase</code> Base of the logarithm (e.g. <code>e</code>, <code>2</code>) for TF-IDF and BM25. <code>tf_mode</code> Term frequency transformation mode for TF-IDF and BM25 (see TF table). <code>idf_mode</code> Inverse document frequency mode for TF-IDF and BM25 (see IDF table)."},{"location":"normalization/#tf-modes","title":"TF Modes","text":"Mode Description <code>'binary'</code> 1 if non-zero <code>'raw'</code> Raw frequency <code>'sqrt'</code> \u221a(raw frequency) <code>'freq'</code> Row-normalized frequency <code>'log'</code> log(1 + frequency)"},{"location":"normalization/#idf-modes","title":"IDF Modes","text":"Mode Description <code>'unary'</code> No IDF applied <code>'base'</code> log(N / df) <code>'smooth'</code> log(1 + N / df) <code>'prob'</code> log((N - df) / df) <code>'bm25'</code> BM25-style IDF weighting"},{"location":"normalization/#notes","title":"Notes","text":"<ul> <li>All normalization functions can operate in-place on CSR format to reduce memory overhead.</li> <li><code>bm25</code> and <code>tfidf</code> are ideal for text, user-item, or interaction data.</li> </ul>"},{"location":"similarity/","title":"\ud83d\udd0d Similarity Functions","text":"<p>SimilariPy provides a suite of similarity functions for sparse matrixes, all implemented in Cython and parallelized with OpenMP. These models compute item-to-item or user-to-user similarity based on vector math or graph-based transformations.</p>"},{"location":"similarity/#similarities","title":"Similarities","text":"Function Description <code>dot_product()</code> Simple raw inner product between vectors. <code>cosine()</code> Cosine similarity with optional shrinkage. <code>asymmetric_cosine(alpha=0.5)</code> Asymmetric variant of cosine similarity, where <code>alpha</code> controls the weighting between vectors. <code>jaccard()</code> Set-based similarity defined as the intersection over union. <code>dice()</code> Harmonic mean of two vectors' lengths. <code>tversky(alpha=1.0, beta=1.0)</code> Tversky similarity, a generalization of Jaccard and Dice. <code>p3alpha(alpha=1.0)</code> Graph-based similarity computed as normalized matrix multiplication with <code>alpha</code> exponentiation. <code>rp3beta(alpha=1.0, beta=1.0)</code> P3alpha variant that penalizes popular items with a <code>beta</code> exponent. <code>s_plus(l=0.5, t1=1.0, t2=1.0, c=0.5)</code> Hybrid model combining Tversky and Cosine with tunable weights."},{"location":"similarity/#common-parameters","title":"Common Parameters","text":"<p>All similarity functions in Similaripy share the following parameters:</p> Parameter Description <code>m1</code> Input sparse matrix for which to calculate the similarity. <code>m2</code> Optional transpose matrix. If <code>None</code>, uses <code>m1.T</code>. (default: <code>None</code>) <code>k</code> Number of top-k items per row. (default: <code>100</code>) <code>h</code> Shrinkage coefficient applied during normalization. <code>threshold</code> Minimum similarity value to retain. Values below are set to zero. (default: <code>0</code>) <code>binary</code> If <code>True</code>, binarizes the input matrix. (default: <code>False</code>) <code>target_rows</code> List or array of row indices to compute. If <code>None</code>, computes for all rows. (default: <code>None</code>) <code>target_cols</code> Subset of columns to consider before applying top-k. Can be an array (applied to all rows) or a sparse matrix (row-specific). (default: <code>None</code>) <code>filter_cols</code> Subset of columns to filter before applying top-k. Can be an array (applied to all rows) or a sparse matrix (row-specific). (default: <code>None</code>) <code>verbose</code> If <code>True</code>, shows a progress bar. (default: <code>True</code>) <code>format_output</code> Output format: <code>'coo'</code> or <code>'csr'</code>. (default: <code>'coo'</code>)Note: <code>'csr'</code> not currently supported on Windows. <code>num_threads</code> Number of threads to use. <code>0</code> means use all available cores. (default: <code>0</code>)"},{"location":"similarity/#notes","title":"Notes","text":"<ul> <li>All similarity functions are implemented in Cython + OpenMP for high-performance computation on CSR matrixes.</li> <li>Computations are fully multi-threaded and scale with CPU cores.</li> <li>Supports CSR and COO sparse matrix formats as output.</li> <li>\u26a0\ufe0f Windows: use <code>format_output='coo'</code> (CSR output is not supported on Windows due to a platform data type mismatch).</li> </ul>"},{"location":"similarity/#math-equations","title":"Math Equations","text":""},{"location":"similarity/#dot-product","title":"Dot Product","text":"<p>\\(s_{xy} = x \\cdot y\\)</p>"},{"location":"similarity/#cosine","title":"Cosine","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\|x\\| \\cdot \\|y\\| + h}\\)</p>"},{"location":"similarity/#asymmetric-cosine","title":"Asymmetric Cosine","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\left(\\sum x_i^2\\right)^\\alpha \\left(\\sum y_i^2\\right)^{1 - \\alpha} + h}\\)</p> <ul> <li><code>\u03b1</code>: Asymmetry coefficient \u2208 [0, 1]</li> </ul>"},{"location":"similarity/#jaccard","title":"Jaccard","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{|x| + |y| - x \\cdot y + h}\\)</p>"},{"location":"similarity/#dice","title":"Dice","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\frac{1}{2}|x| + \\frac{1}{2}|y| - x \\cdot y + h}\\)</p>"},{"location":"similarity/#tversky","title":"Tversky","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\alpha(|x| - x \\cdot y) + \\beta(|y| - x \\cdot y) + x \\cdot y + h}\\)</p> <ul> <li><code>\u03b1</code>, <code>\u03b2</code>: Tversky coefficients \u2208 [0, 1]</li> </ul>"},{"location":"similarity/#p3","title":"P3\u03b1","text":"<p>\\(s_{xy} =  x^\\alpha \\cdot  y^\\alpha\\)</p> <ul> <li><code>\u03b1</code>: P3\u03b1 coefficient \u2208 [0, 1]</li> <li>Normalizion row-wise (L1) is applied before exponentiation</li> </ul>"},{"location":"similarity/#rp3","title":"RP3\u03b2","text":"<p>\\(s_{xy} = \\frac{x^\\alpha \\cdot y^\\alpha}{{pop}(y)^\\beta}\\)</p> <ul> <li><code>\u03b1</code>: P3\u03b1 coefficient \u2208 [0, 1]  </li> <li><code>\u03b2</code>: Popularity penalization coefficient \u2208 [0, 1]</li> <li><code>pop(j)</code> Number of interactions for item j</li> <li>Normalizion row-wise (L1) is applied before exponentiation</li> <li>Penalization is applied before the top k selection</li> </ul>"},{"location":"similarity/#s-plus","title":"S-Plus","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{l \\left(t_1(|x| - x \\cdot y) + t_2(|y| - x \\cdot y) + x \\cdot y\\right) + (1 - l)\\left(\\sum x_i^2\\right)^c \\left(\\sum y_i^2\\right)^{1 - c} + h}\\)</p> <ul> <li><code>l</code>: Balance between Tversky and Cosine parts \u2208 [0, 1]  </li> <li><code>t1</code>, <code>t2</code>: Tversky coefficients \u2208 [0, 1]  </li> <li><code>c</code>: Cosine weighting exponent \u2208 [0, 1]</li> </ul>"},{"location":"api/normalization/","title":"Normalization API","text":""},{"location":"api/normalization/#basic-normalizations","title":"Basic Normalizations","text":"L1, L2, Max Normalizations <p>Normalize a sparse matrix along rows or columns using L1, L2, or max-norm.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>norm</code> <code>str</code> <p>Normalization method ('l1', 'l2', or 'max').</p> <code>'l2'</code> <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>inplace</code> <code>bool</code> <p>Whether to modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>Normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def normalize(\n    X: sps.spmatrix,\n    norm: str = 'l2',\n    axis: int = 1,\n    inplace: bool = False\n) -&gt; sps.csr_matrix:\n    \"\"\"\n    Normalize a sparse matrix along rows or columns using L1, L2, or max-norm.\n\n    Args:\n        X: Input sparse matrix.\n        norm: Normalization method ('l1', 'l2', or 'max').\n        axis: Normalize rows (1) or columns (0).\n        inplace: Whether to modify the matrix in place.\n\n    Returns:\n        Normalized CSR matrix.\n    \"\"\"\n    assert(norm in _NORMALIZATIONS)\n    X = check_matrix(X)\n\n    if not inplace: \n        X = X.copy()\n    if axis == 0: \n        X = X.T\n\n    X = X.tocsr()\n    if norm == 'l1':\n        _norm.inplace_normalize_csr_l1(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr)\n    elif norm == 'l2':\n        _norm.inplace_normalize_csr_l2(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr)\n    elif norm == 'max':\n        _norm.inplace_normalize_csr_max(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr)\n\n    if axis == 0: X = X.T\n    return X.tocsr()\n</code></pre>"},{"location":"api/normalization/#tf-idf-and-bm25-families","title":"TF-IDF and BM25 Families","text":"TF-IDF <p>Apply TF-IDF normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode.</p> <code>'sqrt'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode.</p> <code>'smooth'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>TF-IDF normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def tfidf(\n    X: sps.spmatrix,\n    axis: int = 1,\n    logbase: float = e,\n    tf_mode: str = 'sqrt',\n    idf_mode: str = 'smooth',\n    inplace: bool = False\n) -&gt; sps.csr_matrix:\n    \"\"\"\n    Apply TF-IDF normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode.\n        idf_mode: Inverse document frequency mode.\n        inplace: Modify the matrix in place.\n\n    Returns:\n        TF-IDF normalized CSR matrix.\n    \"\"\"\n    assert(tf_mode in _TF)\n    assert(idf_mode in _IDF)\n    X = check_matrix(X)\n\n    if not inplace: \n        X = X.copy()\n    if axis == 0: \n        X = X.T\n\n    X = X.tocsr()\n    _norm.inplace_normalize_csr_tfidf(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n                                         tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase)\n\n    if axis == 0: \n        X = X.T\n    return X.tocsr()\n</code></pre> BM25 Normalization <p>Apply BM25 normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>k1</code> <code>float</code> <p>Term saturation parameter.</p> <code>1.2</code> <code>b</code> <code>float</code> <p>Length normalization parameter.</p> <code>0.75</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode ('raw', 'log', 'sqrt', etc.).</p> <code>'raw'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode ('bm25', 'smooth', etc.).</p> <code>'bm25'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>BM25-normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def bm25(\n    X: sps.spmatrix,\n    axis: int = 1,\n    k1: float = 1.2,\n    b: float = 0.75,\n    logbase: float = e,\n    tf_mode: str = 'raw',\n    idf_mode: str = 'bm25',\n    inplace: bool = False\n) -&gt; sps.csr_matrix:\n    \"\"\"\n    Apply BM25 normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        k1: Term saturation parameter.\n        b: Length normalization parameter.\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode ('raw', 'log', 'sqrt', etc.).\n        idf_mode: Inverse document frequency mode ('bm25', 'smooth', etc.).\n        inplace: Modify the matrix in place.\n\n    Returns:\n        BM25-normalized CSR matrix.\n    \"\"\"\n    assert(tf_mode in _TF)\n    assert(idf_mode in _IDF)\n    X = check_matrix(X)\n\n    if not inplace: \n        X = X.copy()\n    if axis == 0: \n        X = X.T\n\n    X = X.tocsr()\n    _norm.inplace_normalize_csr_bm25plus(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n                                         k1=k1, b=b, delta=0.0,\n                                         tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase)\n\n    if axis == 0: X = X.T\n    return X.tocsr()\n</code></pre> BM25+ Normalization <p>Apply BM25+ normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>k1</code> <code>float</code> <p>Term saturation parameter.</p> <code>1.2</code> <code>b</code> <code>float</code> <p>Length normalization parameter.</p> <code>0.75</code> <code>delta</code> <code>float</code> <p>BM25+ boosting parameter.</p> <code>1.0</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode.</p> <code>'raw'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode.</p> <code>'bm25'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_matrix</code> <p>BM25+ normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def bm25plus(\n    X: sps.spmatrix,\n    axis: int = 1,\n    k1: float = 1.2,\n    b: float = 0.75,\n    delta: float = 1.0,\n    logbase: float = e,\n    tf_mode: str = 'raw',\n    idf_mode: str = 'bm25',\n    inplace: bool = False\n) -&gt; sps.csr_matrix:\n    \"\"\"\n    Apply BM25+ normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        k1: Term saturation parameter.\n        b: Length normalization parameter.\n        delta: BM25+ boosting parameter.\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode.\n        idf_mode: Inverse document frequency mode.\n        inplace: Modify the matrix in place.\n\n    Returns:\n        BM25+ normalized CSR matrix.\n    \"\"\"\n    assert(tf_mode in _TF)\n    assert(idf_mode in _IDF)\n    X = check_matrix(X)\n\n    if not inplace: \n        X = X.copy()\n    if axis == 0: \n        X = X.T\n\n    X = X.tocsr()\n    _norm.inplace_normalize_csr_bm25plus(shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n                                         k1=k1, b=b, delta=delta,\n                                         tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase)\n\n    if axis == 0: \n        X = X.T\n    return X.tocsr()\n</code></pre>"},{"location":"api/similarity/","title":"Similarity API","text":""},{"location":"api/similarity/#basic-similarities","title":"Basic Similarities","text":"Raw Dot Product <p>Compute dot product similarity between rows of matrix1 and columns of matrix2.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix (e.g., user-item or item-user).</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before similarity computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format: 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 means all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of shape (n_rows, n_cols) in the specified format,</p> <code>spmatrix</code> <p>containing the top-k dot product similarities.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def dot_product(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute dot product similarity between rows of matrix1 and columns of matrix2.\n\n    Args:\n        matrix1: Input sparse matrix (e.g., user-item or item-user).\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before similarity computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format: 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 means all available cores).\n\n    Returns:\n        A sparse matrix of shape (n_rows, n_cols) in the specified format,\n        containing the top-k dot product similarities.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> Cosine Similarity <p>Compute cosine similarity between sparse vectors.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k cosine similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def cosine(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute cosine similarity between sparse vectors.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k cosine similarities in the specified format.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l2=1,\n        c1=0.5, c2=0.5,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> Asymmetric Cosine <p>Compute asymmetric cosine similarity.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix (e.g., user-item or item-user).</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Controls asymmetry in cosine weighting.    <code>alpha=1</code> weighs only matrix1; <code>alpha=0.5</code> is symmetric.</p> <code>0.5</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of shape (n_rows, n_cols) containing the top-k</p> <code>spmatrix</code> <p>asymmetric cosine similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def asymmetric_cosine(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    alpha: float = 0.5,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute asymmetric cosine similarity.\n\n    Args:\n        matrix1: Input sparse matrix (e.g., user-item or item-user).\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Controls asymmetry in cosine weighting.\n               `alpha=1` weighs only matrix1; `alpha=0.5` is symmetric.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of shape (n_rows, n_cols) containing the top-k\n        asymmetric cosine similarities in the specified format.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l2=1,\n        c1=alpha, c2=1-alpha,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> Jaccard Similarity <p>Compute Jaccard similarity (intersection over union).</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k Jaccard similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def jaccard(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute Jaccard similarity (intersection over union).\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k Jaccard similarities in the specified format.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=1, t2=1,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> Dice Similarity <p>Compute Dice similarity (harmonic mean of overlap and size).</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k Dice similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def dice(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute Dice similarity (harmonic mean of overlap and size).\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k Dice similarities in the specified format.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=0.5, t2=0.5,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> Tversky Similarity <p>Compute Tversky similarity between sparse vectors.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Tversky weight for elements unique to matrix1.</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>Tversky weight for elements unique to matrix2.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k Tversky similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def tversky(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute Tversky similarity between sparse vectors.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Tversky weight for elements unique to matrix1.\n        beta: Tversky weight for elements unique to matrix2.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k Tversky similarities in the specified format.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=alpha, t2=beta,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre>"},{"location":"api/similarity/#graph-based-similarities","title":"Graph-Based Similarities","text":"P3\u03b1 <p>Compute P3alpha similarity using a normalized 3-step random walk.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Exponent for transition probabilities to control popularity effect.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k P3alpha similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def p3alpha(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    alpha: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute P3alpha similarity using a normalized 3-step random walk.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Exponent for transition probabilities to control popularity effect.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k P3alpha similarities in the specified format.\n    \"\"\"\n    if matrix2 is None:\n        matrix2 = matrix1.T\n    matrix1 = _normalize(matrix1, norm='l1', axis=1, inplace=False)\n    matrix1.data = np.power(matrix1.data, alpha)\n    matrix2 = _normalize(matrix2, norm='l1', axis=1, inplace=False)\n    matrix2.data = np.power(matrix2.data, alpha)\n    return _sim.s_plus(\n        matrix1=matrix1, matrix2=matrix2,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre> RP3\u03b2 <p>Compute RP3beta similarity: P3alpha with popularity penalization.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Exponent for transition probabilities.</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>Exponent to penalize popularity based on column sums.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k RP3beta similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def rp3beta(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute RP3beta similarity: P3alpha with popularity penalization.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Exponent for transition probabilities.\n        beta: Exponent to penalize popularity based on column sums.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k RP3beta similarities in the specified format.\n    \"\"\"\n    if matrix2 is None:\n        matrix2 = matrix1.T\n    pop_m2 = matrix2.sum(axis=0).A1\n    matrix1 = _normalize(matrix1, norm='l1', axis=1, inplace=False)\n    matrix1.data = np.power(matrix1.data, alpha)\n    matrix2 = _normalize(matrix2, norm='l1', axis=1, inplace=False)\n    matrix2.data = np.power(matrix2.data, alpha)\n    return _sim.s_plus(\n        matrix1=matrix1, matrix2=matrix2,\n        weight_depop_matrix2=pop_m2,\n        p2=beta,\n        l3=1,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre>"},{"location":"api/similarity/#hybrid-similarity","title":"Hybrid Similarity","text":"S Plus <p>Compute hybrid S Plus similarity with weighted Tversky and Cosine components.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>spmatrix</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[spmatrix]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>l</code> <code>float</code> <p>Mixing parameter between Tversky (l1) and Cosine (l2).</p> <code>0.5</code> <code>t1</code> <code>float</code> <p>Tversky alpha for matrix1.</p> <code>1.0</code> <code>t2</code> <code>float</code> <p>Tversky beta for matrix2.</p> <code>1.0</code> <code>c</code> <code>float</code> <p>Cosine exponent coefficient.</p> <code>0.5</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value applied to similarity scores.</p> <code>0.0</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, spmatrix]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <p>Returns:</p> Type Description <code>spmatrix</code> <p>A sparse matrix of top-k similarities based on combined Tversky and Cosine scoring.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def s_plus(\n    matrix1: spmatrix,\n    matrix2: Optional[spmatrix] = None,\n    l: float = 0.5,\n    t1: float = 1.0,\n    t2: float = 1.0,\n    c: float = 0.5,\n    k: int = 100,\n    shrink: float = 0.0,\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, spmatrix]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0\n) -&gt; spmatrix:\n    \"\"\"\n    Compute hybrid S Plus similarity with weighted Tversky and Cosine components.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        l: Mixing parameter between Tversky (l1) and Cosine (l2).\n        t1: Tversky alpha for matrix1.\n        t2: Tversky beta for matrix2.\n        c: Cosine exponent coefficient.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value applied to similarity scores.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n\n    Returns:\n        A sparse matrix of top-k similarities based on combined Tversky and Cosine scoring.\n    \"\"\"\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=l, l2=1-l,\n        t1=t1, t2=t2,\n        c1=c, c2=1-c,\n        k=k, shrink=shrink, threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads\n    )\n</code></pre>"}]}