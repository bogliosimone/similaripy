{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-similaripys-documentation","title":"Welcome to SimilariPy\u2019s documentation!","text":"<p>SimilariPy is a Python package that provides high-performance KNN similarity and normalization functions, optimized for sparse matrices.</p>"},{"location":"#why-similaripy","title":"\ud83d\udd25 Why SimilariPy?","text":"<ul> <li>Fast: powered by Cython and OpenMP for fast parallel execution</li> <li>Sparse matrix focus: optimized for Scipy CSR/COO formats</li> <li>Wide similarity coverage: Dot Product, Cosine, Tversky, P3\u03b1, RP3\u03b2, and more</li> <li>Flexible normalization: includes L1, L2, TF-IDF, BM25, BM25+</li> </ul>"},{"location":"#guide","title":"\ud83d\udcda Guide","text":"<ul> <li>Installation instructions</li> <li>Quickstart guide</li> <li>Quick reference to similarity functions</li> <li>Quick reference to normalization functions</li> <li>Full API documentation</li> </ul>"},{"location":"#key-performance-optimizations","title":"\u26a1 Key Performance Optimizations","text":"<p>SimilariPy achieves high performance through several key optimizations:</p> <ul> <li>Cython compilation: Core algorithms compiled to C++ for native-speed execution</li> <li>OpenMP parallelization: Multi-threaded execution scales with available CPU cores</li> <li>GIL-free computation: Releases Python's Global Interpreter Lock during heavy computation</li> <li>CSR-optimized: Direct memory access patterns optimized for Compressed Sparse Row format</li> <li>Column-blocked accumulation: Tiles the output columns into cache-sized blocks with popularity-based reordering, dramatically reducing L2 cache misses on large matrices</li> <li>Cache-friendly data structures: Sequential vector storage for hot-path accumulators ensures optimal CPU cache utilization and memory bandwidth</li> <li>Pre-allocated buffers: Reuses row buffers across iterations, eliminating millions of allocations per computation</li> <li>Float32 precision: Uses 32-bit floats for matrix values instead of 64-bit for 2\u00d7 memory bandwidth</li> <li>Fused types: Single codebase supports both int32/int64 matrix indices without overhead or code duplication</li> <li>Top-K filtering: Early termination and efficient heap structures minimize unnecessary computation</li> </ul>"},{"location":"guide/","title":"\ud83d\udccc Getting Started","text":"<p>SimilariPy provides high-performance KNN similarity functions in Python, optimized for sparse matrices.</p> <p>Primarily designed for Recommender Systems and Information Retrieval (IR) tasks, but can be applied to other domains as well.</p> <p>The package also includes a set of normalization functions useful for pre-processing data in-place before the similarity computation.</p>"},{"location":"guide/#similarity-functions","title":"Similarity Functions","text":"<p>SimilariPy provides a range of high-performance similarity functions for sparse matrices. All functions are multi-threaded and implemented in Cython + OpenMP for fast parallel computation on CSR matrixes.</p>"},{"location":"guide/#core","title":"Core","text":"<ul> <li>Dot Product \u2013 Simple raw inner product between vectors.</li> <li>Cosine \u2013 Normalized dot product based on L2 norm.</li> <li>Asymmetric Cosine \u2013 Skewed cosine similarity using an <code>alpha</code> parameter.</li> <li>Jaccard, Dice, Tversky \u2013 Set-based generalized similarities.</li> </ul>"},{"location":"guide/#graph-based","title":"Graph-Based","text":"<ul> <li>P3\u03b1 \u2013 Graph-based similarity computed through random walk propagation with exponentiation.</li> <li>RP3\u03b2 \u2013 Similar to P3\u03b1 but includes popularity penalization using a <code>beta</code> parameter.</li> </ul>"},{"location":"guide/#advanced","title":"Advanced","text":"<ul> <li>S-Plus \u2013 A hybrid model combining Tversky and Cosine components, with RP3Beta-style depopularization and full control over weights and smoothing. </li> </ul>"},{"location":"guide/#normalization-functions","title":"Normalization Functions","text":"<p>SimilariPy provides a suite of normalization functions for sparse matrix pre-processing. All functions are implemented in Cython and can operate in-place on CSR matrixes for maximum performance and memory efficiency.</p> <ul> <li>L1, L2 \u2013 Applies row- or column-wise normalization.</li> <li>TF-IDF \u2013 Computes TF-IDF weighting with customizable term-frequency and IDF modes.</li> <li>BM25 \u2013 Applies classic BM25 weighting used in information retrieval.</li> <li>BM25+ \u2013 Variant of BM25 with additive smoothing for low-frequency terms.</li> </ul>"},{"location":"guide/#example","title":"Example","text":"<p>Here\u2019s a minimal example to get you up and running with SimilariPy:</p> <pre><code>import similaripy as sim\nimport scipy.sparse as sps\n\n# Create a random User-Rating Matrix (URM)\nurm = sps.random_array((1000, 2000), density=0.025)\n\n# Normalize the URM using BM25\nurm = sim.normalization.bm25(urm)\n\n# Train an item-item cosine similarity model\nsimilarity_matrix = sim.cosine(urm.T, k=50)\n\n# Compute recommendations for user 1, 14, 8 \n# filtering out already-seen items\nrecommendations = sim.dot_product(\n    urm,\n    similarity_matrix.T,\n    k=100,\n    target_rows=[1, 14, 8],\n    filter_cols=urm\n)\n</code></pre> <p>Tips:</p> <ul> <li><code>urm.T</code> is used to switch from user-item to item-user when training the similarity model.</li> <li>You can use <code>bm25plus</code>, <code>tfidf</code>, or <code>normalize</code> for different pre-processing strategies.</li> <li>All operations are multithreaded and scale with available CPU cores.</li> </ul>"},{"location":"guide/#in-depth-introduction","title":"In-depth Introduction","text":"<p>Looking for a full end-to-end example?</p> <p>Check the MovieLens notebook: - MovieLens 32M Item-Item Recommender (GitHub)</p>"},{"location":"installation/","title":"\ud83d\udce6 Installation","text":""},{"location":"installation/#installation_1","title":"Installation","text":"<p>SimilariPy can be installed from PyPI with:</p> <pre><code>pip install similaripy\n</code></pre>"},{"location":"installation/#gcc-compiler-required","title":"GCC Compiler - Required","text":"<p>To install the package and compile the Cython code, a GCC-compatible compiler with OpenMP is required.</p>"},{"location":"installation/#ubuntu-debian","title":"Ubuntu / Debian","text":"<p>Install the official dev-tools:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential\n</code></pre>"},{"location":"installation/#macos-intel-apple-silicon","title":"MacOS (Intel &amp; Apple Silicon)","text":"<p>Install GCC with homebrew:</p> <pre><code>brew install gcc\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>Install the official Visual C++ Build Tools.</p> <p>\u26a0\ufe0f On Windows, use the default format_output='coo' in all similarity functions, as 'csr' is currently not supported.</p>"},{"location":"installation/#optional-optimization-intel-mkl-for-intel-cpus","title":"Optional Optimization: Intel MKL for Intel CPUs","text":"<p>For Intel CPUs, using SciPy/Numpy with MKL (Math Kernel Library) is highly recommended for best performance. The easiest way to achieve this is to install them via Anaconda.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"Package Version numpy &gt;= 1.22.4 scipy &gt;= 1.12.0"},{"location":"normalization/","title":"\ud83e\uddee Normalization Functions","text":"<p>SimilariPy includes several normalization functions designed for sparse matrix pre-processing. All functions are implemented in Cython and support in-place operation for memory efficiency.</p>"},{"location":"normalization/#normalizations","title":"Normalizations","text":"Function Description <code>normalize(X, norm='l2')</code> Standard row or column-wise normalization. Supports <code>'l1'</code>, <code>'l2'</code>, and <code>'max'</code>. <code>tfidf(X, tf_mode='sqrt', idf_mode='smooth')</code> TF-IDF weighting with customizable term-frequency and inverse-document-frequency modes. <code>bm25(X, k1=1.2, b=0.75)</code> BM25 weighting, a standard IR normalization used for relevance scoring. <code>bm25plus(X, k1=1.2, b=0.75, delta=1.0)</code> BM25+ variant with an additional smoothing <code>delta</code> parameter."},{"location":"normalization/#common-parameters","title":"Common Parameters","text":"<p>All normalization functions in SimilariPy share the following parameters:</p> Parameter Description <code>axis</code> <code>1</code> for row-wise (default), <code>0</code> for column-wise normalization. <code>inplace</code> If <code>True</code>, modifies the input matrix in-place. <code>logbase</code> Base of the logarithm (e.g. <code>e</code>, <code>2</code>) for TF-IDF and BM25. <code>tf_mode</code> Term frequency transformation mode for TF-IDF and BM25 (see TF table). <code>idf_mode</code> Inverse document frequency mode for TF-IDF and BM25 (see IDF table)."},{"location":"normalization/#tf-modes","title":"TF Modes","text":"Mode Description <code>'binary'</code> 1 if non-zero <code>'raw'</code> Raw frequency <code>'sqrt'</code> \u221a(raw frequency) <code>'freq'</code> Row-normalized frequency <code>'log'</code> log(1 + frequency)"},{"location":"normalization/#idf-modes","title":"IDF Modes","text":"Mode Description <code>'unary'</code> No IDF applied <code>'base'</code> log(N / df) <code>'smooth'</code> log(1 + N / df) <code>'prob'</code> log((N - df) / df) <code>'bm25'</code> BM25-style IDF weighting"},{"location":"normalization/#notes","title":"Notes","text":"<ul> <li>All normalization functions can operate in-place on CSR format to reduce memory overhead.</li> <li><code>bm25</code> and <code>tfidf</code> are ideal for text, user-item, or interaction data.</li> </ul>"},{"location":"similarity/","title":"\ud83d\udd0d Similarity Functions","text":"<p>SimilariPy provides a suite of similarity functions for sparse matrixes, all implemented in Cython and parallelized with OpenMP. These models compute item-to-item or user-to-user similarity based on vector math or graph-based transformations.</p>"},{"location":"similarity/#similarities","title":"Similarities","text":"Function Description <code>dot_product()</code> Simple raw inner product between vectors. <code>cosine()</code> Cosine similarity with optional shrinkage. <code>asymmetric_cosine(alpha=0.5)</code> Asymmetric variant of cosine similarity, where <code>alpha</code> controls the weighting between vectors. <code>jaccard()</code> Set-based similarity defined as the intersection over union. <code>dice()</code> Harmonic mean of two vectors' lengths. <code>tversky(alpha=1.0, beta=1.0)</code> Tversky similarity, a generalization of Jaccard and Dice. <code>p3alpha(alpha=1.0)</code> Graph-based similarity computed as normalized matrix multiplication with <code>alpha</code> exponentiation. <code>rp3beta(alpha=1.0, beta=1.0)</code> P3alpha variant that penalizes popular items with a <code>beta</code> exponent. <code>s_plus(l1=0.5, l2=0.5, l3=0.0, t1=1.0, t2=1.0, c1=0.5, c2=0.5, alpha=1, pop1='none', pop2='none', beta1=0.0, beta2=0.0)</code> Hybrid similarity model that combines Tversky and Cosine normalizations with RP3Beta-style depopularization, controlled by tunable weights. The <code>pop1</code> and <code>pop2</code> parameters define item popularity weights and may be provided as custom arrays of arbitrary values, or initialized with built-in options: <code>'sum'</code>: use the sum of interactions per item; <code>'none'</code>: disable popularity weighting  (default: <code>'none'</code>)"},{"location":"similarity/#common-parameters","title":"Common Parameters","text":"<p>All similarity functions in Similaripy share the following parameters:</p> Parameter Description <code>m1</code> Input sparse matrix for which to calculate the similarity. <code>m2</code> Optional transpose matrix. If <code>None</code>, uses <code>m1.T</code>. (default: <code>None</code>) <code>k</code> Number of top-k items per row. (default: <code>100</code>) <code>h</code> Shrinkage coefficient applied during normalization. <code>threshold</code> Minimum similarity value to retain. Values below are set to zero. (default: <code>0</code>) <code>shrink_type</code> Shrinkage type: <code>stabilized</code>, <code>bayesian</code>, or <code>additive</code>.  (default: <code>stabilized</code>) <code>binary</code> If <code>True</code>, binarizes the input matrix. (default: <code>False</code>) <code>target_rows</code> List or array of row indices to compute. If <code>None</code>, computes for all rows. (default: <code>None</code>) <code>target_cols</code> Subset of columns to consider before applying top-k. Can be an array (applied to all rows) or a sparse matrix (row-specific). (default: <code>None</code>) <code>filter_cols</code> Subset of columns to filter before applying top-k. Can be an array (applied to all rows) or a sparse matrix (row-specific). (default: <code>None</code>) <code>verbose</code> If <code>True</code>, shows a progress bar. (default: <code>True</code>) <code>format_output</code> Output format: <code>'coo'</code> or <code>'csr'</code>. (default: <code>'coo'</code>)Note: <code>'csr'</code> not currently supported on Windows. <code>num_threads</code> Number of threads to use. <code>0</code> means use all available cores. (default: <code>0</code>) <code>block_size</code> Block size for column-blocked accumulation. <code>0</code> = auto (recommended), <code>None</code> = disabled. (default: <code>0</code>)"},{"location":"similarity/#shrinkage-types","title":"Shrinkage Types","text":"<p>The shrinkage equations are displayed with the cosine normalization for simplicity, however, they are available in all the similarities.</p>"},{"location":"similarity/#stabilized-shrinkage","title":"Stabilized Shrinkage","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\sqrt{\\sum_i x_i^2} \\cdot \\sqrt{\\sum_i y_i^2} + h}\\)</p> <ul> <li>Prevents instability when norms are small.</li> <li><code>h</code> acts as the shrinkage strength.</li> <li><code>shrink_type = 'stabilized'</code></li> </ul>"},{"location":"similarity/#bayesian-shrinkage","title":"Bayesian Shrinkage","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\sqrt{\\sum_i x_i^2} \\cdot \\sqrt{\\sum_i y_i^2}} \\cdot \\frac{x \\cdot y}{x \\cdot y + h}\\)</p> <ul> <li>Penalizes similarities with items with low overlap support.  </li> <li><code>h</code> acts as the shrinkage strength.</li> <li><code>shrink_type = 'bayesian'</code></li> </ul>"},{"location":"similarity/#additive-shrinkage","title":"Additive Shrinkage","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\sqrt{\\sum_i (x_i^2 + h)} \\cdot \\sqrt{\\sum_i (y_i^2 + h)}}\\)</p> <ul> <li>Penalizes similarities with items with low support.</li> <li>Adds shrinkage directly into the cosine denominator norms.</li> <li><code>h</code> acts as the shrinkage strength.</li> <li><code>shrink_type = 'additive'</code></li> </ul>"},{"location":"similarity/#notes","title":"Notes","text":"<ul> <li>All similarity functions are implemented in Cython + OpenMP for high-performance computation on CSR matrixes.</li> <li>Computations are fully multi-threaded and scale with CPU cores.</li> <li>Supports CSR and COO sparse matrix formats as output.</li> <li>\u26a0\ufe0f Windows: use <code>format_output='coo'</code> (CSR output is not supported on Windows due to a platform data type mismatch).</li> </ul>"},{"location":"similarity/#math-equations","title":"Math Equations","text":""},{"location":"similarity/#dot-product","title":"Dot Product","text":"<p>\\(s_{xy} = x \\cdot y\\)</p>"},{"location":"similarity/#cosine","title":"Cosine","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\|x\\| \\cdot \\|y\\|}\\)</p>"},{"location":"similarity/#asymmetric-cosine","title":"Asymmetric Cosine","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\left(\\sum x_i^2\\right)^\\alpha \\left(\\sum y_i^2\\right)^{1 - \\alpha}}\\)</p> <ul> <li><code>\u03b1</code>: Asymmetry coefficient \u2208 [0, 1]</li> </ul>"},{"location":"similarity/#jaccard","title":"Jaccard","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{|x| + |y| - x \\cdot y}\\)</p>"},{"location":"similarity/#dice","title":"Dice","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\frac{1}{2}|x| + \\frac{1}{2}|y| - x \\cdot y}\\)</p>"},{"location":"similarity/#tversky","title":"Tversky","text":"<p>\\(s_{xy} = \\frac{x \\cdot y}{\\alpha(|x| - x \\cdot y) + \\beta(|y| - x \\cdot y) + x \\cdot y}\\)</p> <ul> <li><code>\u03b1</code>, <code>\u03b2</code>: Tversky coefficients \u2208 [0, 1]</li> </ul>"},{"location":"similarity/#p3","title":"P3\u03b1","text":"<p>\\(s_{xy} =  x^\\alpha \\cdot  y^\\alpha\\)</p> <ul> <li><code>\u03b1</code>: P3\u03b1 coefficient \u2208 [0, 1]</li> <li>Normalizion row-wise (L1) is applied before exponentiation</li> </ul>"},{"location":"similarity/#rp3","title":"RP3\u03b2","text":"<p>\\(s_{xy} = \\frac{x^\\alpha \\cdot y^\\alpha}{{pop}(y)^\\beta}\\)</p> <ul> <li><code>\u03b1</code>: P3\u03b1 coefficient \u2208 [0, 1]  </li> <li><code>\u03b2</code>: Popularity penalization coefficient \u2208 [0, 1]</li> <li><code>pop(y)</code> Number of interactions for item y</li> <li>Normalizion row-wise (L1) is applied before exponentiation</li> <li>Penalization is applied before the top k selection</li> </ul>"},{"location":"similarity/#s-plus","title":"S-Plus","text":"<p>\\(s_{xy} = \\frac{(x \\cdot y)^\\alpha}{l_1 \\left(t_1(|x| - x \\cdot y) + t_2(|y| - x \\cdot y) + x \\cdot y\\right) + l_2\\left(\\sum x_i^2\\right)^{c_1} \\cdot \\left(\\sum y_i^2\\right)^{c_2} + l_3(pop_1(x)^{\\beta_1} \\cdot pop_2(y)^{\\beta_2})}\\)</p> <ul> <li><code>l1</code>, <code>l2</code>: Tversky,Cosine normalization strength \u2208 [0, 1]</li> <li><code>l3</code>: Popularity penalization strength \u2208 [0, 1]  </li> <li><code>t1</code>, <code>t2</code>: Tversky coefficients \u2208 [0, 1]  </li> <li><code>c1</code>, <code>c2</code>: Cosine weighting exponent \u2208 [0, 1]</li> <li><code>\u03b1</code>: Coefficient for the raw interaction overlap (different from P3\u03b1)</li> <li><code>\u03b21</code>, <code>\u03b22</code>: Popularity penalization coefficient for the item x/y \u2208 [0, 1]</li> <li><code>pop(x)</code>, <code>pop(y)</code>: Popularity value for the item x/y</li> </ul>"},{"location":"api/normalization/","title":"Normalization API","text":"L1, L2, Max Normalizations TF-IDF BM25 BM25+"},{"location":"api/normalization/#similaripy.normalization.normalize","title":"normalize","text":"<pre><code>normalize(X: sparray, norm: str = 'l2', axis: int = 1, inplace: bool = False) -&gt; sps.csr_array\n</code></pre> <p>Normalize a sparse matrix along rows or columns using L1, L2, or max-norm.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>norm</code> <code>str</code> <p>Normalization method ('l1', 'l2', or 'max').</p> <code>'l2'</code> <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>inplace</code> <code>bool</code> <p>Whether to modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_array</code> <p>Normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def normalize(\n    X: sps.sparray,\n    norm: str = 'l2',\n    axis: int = 1,\n    inplace: bool = False,\n) -&gt; sps.csr_array:\n    \"\"\"\n    Normalize a sparse matrix along rows or columns using L1, L2, or max-norm.\n\n    Args:\n        X: Input sparse matrix.\n        norm: Normalization method ('l1', 'l2', or 'max').\n        axis: Normalize rows (1) or columns (0).\n        inplace: Whether to modify the matrix in place.\n\n    Returns:\n        Normalized CSR matrix.\n    \"\"\"\n    if norm not in _NORMALIZATIONS:\n        raise ValueError(f\"norm must be one of {_NORMALIZATIONS}, got '{norm}'\")\n    X = _prepare_csr(X, axis, inplace)\n    _NORM_DISPATCH[norm](shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr)\n    return _finalize_csr(X, axis)\n</code></pre>"},{"location":"api/normalization/#similaripy.normalization.tfidf","title":"tfidf","text":"<pre><code>tfidf(X: sparray, axis: int = 1, logbase: float = e, tf_mode: str = 'sqrt', idf_mode: str = 'smooth', inplace: bool = False) -&gt; sps.csr_array\n</code></pre> <p>Apply TF-IDF normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode.</p> <code>'sqrt'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode.</p> <code>'smooth'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_array</code> <p>TF-IDF normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def tfidf(\n    X: sps.sparray,\n    axis: int = 1,\n    logbase: float = e,\n    tf_mode: str = 'sqrt',\n    idf_mode: str = 'smooth',\n    inplace: bool = False,\n) -&gt; sps.csr_array:\n    \"\"\"\n    Apply TF-IDF normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode.\n        idf_mode: Inverse document frequency mode.\n        inplace: Modify the matrix in place.\n\n    Returns:\n        TF-IDF normalized CSR matrix.\n    \"\"\"\n    _validate_modes(tf_mode, idf_mode)\n    X = _prepare_csr(X, axis, inplace)\n    _norm.inplace_normalize_csr_tfidf(\n        shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n        tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase,\n    )\n    return _finalize_csr(X, axis)\n</code></pre>"},{"location":"api/normalization/#similaripy.normalization.bm25","title":"bm25","text":"<pre><code>bm25(X: sparray, axis: int = 1, k1: float = 1.2, b: float = 0.75, logbase: float = e, tf_mode: str = 'raw', idf_mode: str = 'bm25', inplace: bool = False) -&gt; sps.csr_array\n</code></pre> <p>Apply BM25 normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>k1</code> <code>float</code> <p>Term saturation parameter.</p> <code>1.2</code> <code>b</code> <code>float</code> <p>Length normalization parameter.</p> <code>0.75</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode ('raw', 'log', 'sqrt', etc.).</p> <code>'raw'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode ('bm25', 'smooth', etc.).</p> <code>'bm25'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_array</code> <p>BM25-normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def bm25(\n    X: sps.sparray,\n    axis: int = 1,\n    k1: float = 1.2,\n    b: float = 0.75,\n    logbase: float = e,\n    tf_mode: str = 'raw',\n    idf_mode: str = 'bm25',\n    inplace: bool = False,\n) -&gt; sps.csr_array:\n    \"\"\"\n    Apply BM25 normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        k1: Term saturation parameter.\n        b: Length normalization parameter.\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode ('raw', 'log', 'sqrt', etc.).\n        idf_mode: Inverse document frequency mode ('bm25', 'smooth', etc.).\n        inplace: Modify the matrix in place.\n\n    Returns:\n        BM25-normalized CSR matrix.\n    \"\"\"\n    _validate_modes(tf_mode, idf_mode)\n    X = _prepare_csr(X, axis, inplace)\n    _norm.inplace_normalize_csr_bm25plus(\n        shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n        k1=k1, b=b, delta=0.0,\n        tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase,\n    )\n    return _finalize_csr(X, axis)\n</code></pre>"},{"location":"api/normalization/#similaripy.normalization.bm25plus","title":"bm25plus","text":"<pre><code>bm25plus(X: sparray, axis: int = 1, k1: float = 1.2, b: float = 0.75, delta: float = 1.0, logbase: float = e, tf_mode: str = 'raw', idf_mode: str = 'bm25', inplace: bool = False) -&gt; sps.csr_array\n</code></pre> <p>Apply BM25+ normalization to a sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>axis</code> <code>int</code> <p>Normalize rows (1) or columns (0).</p> <code>1</code> <code>k1</code> <code>float</code> <p>Term saturation parameter.</p> <code>1.2</code> <code>b</code> <code>float</code> <p>Length normalization parameter.</p> <code>0.75</code> <code>delta</code> <code>float</code> <p>BM25+ boosting parameter.</p> <code>1.0</code> <code>logbase</code> <code>float</code> <p>Logarithm base.</p> <code>e</code> <code>tf_mode</code> <code>str</code> <p>Term frequency mode.</p> <code>'raw'</code> <code>idf_mode</code> <code>str</code> <p>Inverse document frequency mode.</p> <code>'bm25'</code> <code>inplace</code> <code>bool</code> <p>Modify the matrix in place.</p> <code>False</code> <p>Returns:</p> Type Description <code>csr_array</code> <p>BM25+ normalized CSR matrix.</p> Source code in <code>similaripy/normalization.py</code> <pre><code>def bm25plus(\n    X: sps.sparray,\n    axis: int = 1,\n    k1: float = 1.2,\n    b: float = 0.75,\n    delta: float = 1.0,\n    logbase: float = e,\n    tf_mode: str = 'raw',\n    idf_mode: str = 'bm25',\n    inplace: bool = False,\n) -&gt; sps.csr_array:\n    \"\"\"\n    Apply BM25+ normalization to a sparse matrix.\n\n    Args:\n        X: Input sparse matrix.\n        axis: Normalize rows (1) or columns (0).\n        k1: Term saturation parameter.\n        b: Length normalization parameter.\n        delta: BM25+ boosting parameter.\n        logbase: Logarithm base.\n        tf_mode: Term frequency mode.\n        idf_mode: Inverse document frequency mode.\n        inplace: Modify the matrix in place.\n\n    Returns:\n        BM25+ normalized CSR matrix.\n    \"\"\"\n    _validate_modes(tf_mode, idf_mode)\n    X = _prepare_csr(X, axis, inplace)\n    _norm.inplace_normalize_csr_bm25plus(\n        shape=X.shape, data=X.data, indices=X.indices, indptr=X.indptr,\n        k1=k1, b=b, delta=delta,\n        tf_mode=tf_mode, idf_mode=idf_mode, logbase=logbase,\n    )\n    return _finalize_csr(X, axis)\n</code></pre>"},{"location":"api/similarity/","title":"Similarity API","text":"Raw Dot Product Cosine Similarity Asymmetric Cosine Jaccard Similarity Dice Similarity Tversky Similarity P3\u03b1 RP3\u03b2 S Plus"},{"location":"api/similarity/#similaripy.similarity.dot_product","title":"dot_product","text":"<pre><code>dot_product(matrix1: sparray, matrix2: Optional[sparray] = None, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute dot product similarity between rows of matrix1 and columns of matrix2.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix (e.g., user-item or item-user).</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before similarity computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format: 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 means all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of shape (n_rows, n_cols) in the specified format,</p> <code>sparray</code> <p>containing the top-k dot product similarities.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def dot_product(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute dot product similarity between rows of matrix1 and columns of matrix2.\n\n    Args:\n        matrix1: Input sparse matrix (e.g., user-item or item-user).\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before similarity computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format: 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 means all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of shape (n_rows, n_cols) in the specified format,\n        containing the top-k dot product similarities.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.cosine","title":"cosine","text":"<pre><code>cosine(matrix1: sparray, matrix2: Optional[sparray] = None, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute cosine similarity between sparse vectors.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k cosine similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def cosine(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute cosine similarity between sparse vectors.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k cosine similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l2=1,\n        c1=0.5, c2=0.5,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.asymmetric_cosine","title":"asymmetric_cosine","text":"<pre><code>asymmetric_cosine(matrix1: sparray, matrix2: Optional[sparray] = None, alpha: float = 0.5, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute asymmetric cosine similarity.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix (e.g., user-item or item-user).</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Controls asymmetry in cosine weighting.    <code>alpha=1</code> weighs only matrix1; <code>alpha=0.5</code> is symmetric.</p> <code>0.5</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of shape (n_rows, n_cols) containing the top-k</p> <code>sparray</code> <p>asymmetric cosine similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def asymmetric_cosine(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    alpha: float = 0.5,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute asymmetric cosine similarity.\n\n    Args:\n        matrix1: Input sparse matrix (e.g., user-item or item-user).\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Controls asymmetry in cosine weighting.\n               `alpha=1` weighs only matrix1; `alpha=0.5` is symmetric.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of shape (n_rows, n_cols) containing the top-k\n        asymmetric cosine similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l2=1,\n        c1=alpha, c2=1-alpha,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.jaccard","title":"jaccard","text":"<pre><code>jaccard(matrix1: sparray, matrix2: Optional[sparray] = None, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute Jaccard similarity (intersection over union).</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k Jaccard similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def jaccard(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute Jaccard similarity (intersection over union).\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k Jaccard similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=1, t2=1,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.dice","title":"dice","text":"<pre><code>dice(matrix1: sparray, matrix2: Optional[sparray] = None, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute Dice similarity (harmonic mean of overlap and size).</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k Dice similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def dice(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute Dice similarity (harmonic mean of overlap and size).\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k Dice similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=0.5, t2=0.5,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.tversky","title":"tversky","text":"<pre><code>tversky(matrix1: sparray, matrix2: Optional[sparray] = None, alpha: float = 1.0, beta: float = 1.0, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute Tversky similarity between sparse vectors.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Tversky weight for elements unique to matrix1.</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>Tversky weight for elements unique to matrix2.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k Tversky similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def tversky(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute Tversky similarity between sparse vectors.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Tversky weight for elements unique to matrix1.\n        beta: Tversky weight for elements unique to matrix2.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k Tversky similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=1,\n        t1=alpha, t2=beta,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.p3alpha","title":"p3alpha","text":"<pre><code>p3alpha(matrix1: sparray, matrix2: Optional[sparray] = None, alpha: float = 1.0, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute P3alpha similarity using a normalized 3-step random walk.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Exponent for transition probabilities to control popularity effect.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k P3alpha similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def p3alpha(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    alpha: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute P3alpha similarity using a normalized 3-step random walk.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Exponent for transition probabilities to control popularity effect.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k P3alpha similarities in the specified format.\n    \"\"\"\n    if matrix2 is None:\n        matrix2 = matrix1.T\n    matrix1 = _normalize(matrix1, norm='l1', axis=1, inplace=False)\n    matrix1.data = np.power(matrix1.data, alpha)\n    matrix2 = _normalize(matrix2, norm='l1', axis=1, inplace=False)\n    matrix2.data = np.power(matrix2.data, alpha)\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1=matrix1, matrix2=matrix2,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.rp3beta","title":"rp3beta","text":"<pre><code>rp3beta(matrix1: sparray, matrix2: Optional[sparray] = None, alpha: float = 1.0, beta: float = 1.0, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Compute RP3beta similarity: P3alpha with popularity penalization.</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Exponent for transition probabilities.</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>Exponent to penalize popularity based on column sums.</p> <code>1.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k RP3beta similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def rp3beta(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    alpha: float = 1.0,\n    beta: float = 1.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Compute RP3beta similarity: P3alpha with popularity penalization.\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        alpha: Exponent for transition probabilities.\n        beta: Exponent to penalize popularity based on column sums.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k RP3beta similarities in the specified format.\n    \"\"\"\n    if matrix2 is None:\n        matrix2 = matrix1.T\n    pop_m2 = np.asarray(matrix2.sum(axis=0)).ravel()\n    matrix1 = _normalize(matrix1, norm='l1', axis=1, inplace=False)\n    matrix1.data = np.power(matrix1.data, alpha)\n    matrix2 = _normalize(matrix2, norm='l1', axis=1, inplace=False)\n    matrix2.data = np.power(matrix2.data, alpha)\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1=matrix1, matrix2=matrix2,\n        weight_depop_matrix2=pop_m2,\n        p2=beta,\n        l3=1,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"},{"location":"api/similarity/#similaripy.similarity.s_plus","title":"s_plus","text":"<pre><code>s_plus(matrix1: sparray, matrix2: Optional[sparray] = None, l1: float = 0.5, l2: float = 0.5, l3: float = 0.0, t1: float = 1.0, t2: float = 1.0, c1: float = 0.5, c2: float = 0.5, pop1: Optional[Union[Literal['none', 'sum'], ndarray]] = 'none', pop2: Optional[Union[Literal['none', 'sum'], ndarray]] = 'none', alpha: float = 1.0, beta1: float = 0.0, beta2: float = 0.0, k: int = 100, shrink: float = 0.0, shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized', threshold: float = 0.0, binary: bool = False, target_rows: Optional[Union[list[int], ndarray]] = None, target_cols: Optional[Union[list[int], ndarray, sparray]] = None, filter_cols: Optional[Union[list[int], ndarray, sparray]] = None, verbose: bool = True, format_output: Literal['csr', 'coo'] = 'coo', num_threads: int = 0, block_size: Optional[int] = 0) -&gt; sparray\n</code></pre> <p>Combines Tversky and Cosine normalizations with RP3Beta-style depopularization, fully controlled by tunable weights</p> <p>Parameters:</p> Name Type Description Default <code>matrix1</code> <code>sparray</code> <p>Input sparse matrix.</p> required <code>matrix2</code> <code>Optional[sparray]</code> <p>Optional second matrix. If None, uses matrix1.T.</p> <code>None</code> <code>l1</code> <code>float</code> <p>Tversky normalization strength.</p> <code>0.5</code> <code>l2</code> <code>float</code> <p>Cosine normalization strength.</p> <code>0.5</code> <code>l3</code> <code>float</code> <p>Popularity penalization strength.</p> <code>0.0</code> <code>t1</code> <code>float</code> <p>Tversky alpha for matrix1.</p> <code>1.0</code> <code>t2</code> <code>float</code> <p>Tversky beta for matrix2.</p> <code>1.0</code> <code>c1</code> <code>float</code> <p>Cosine exponent coefficient for matrix1.</p> <code>0.5</code> <code>c2</code> <code>float</code> <p>Cosine exponent coefficient for matrix2.</p> <code>0.5</code> <code>pop1</code> <code>Optional[Union[Literal['none', 'sum'], ndarray]]</code> <p>Popularity weights for matrix1. 'none', 'sum', or custom array.</p> <code>'none'</code> <code>pop2</code> <code>Optional[Union[Literal['none', 'sum'], ndarray]]</code> <p>Popularity weights for matrix2. 'none', 'sum', or custom array.</p> <code>'none'</code> <code>alpha</code> <code>float</code> <p>Coefficient applied on the raw similarity value before normalizations.</p> <code>1.0</code> <code>beta1</code> <code>float</code> <p>Popularity penalization coefficient for matrix1 items.</p> <code>0.0</code> <code>beta2</code> <code>float</code> <p>Popularity penalization coefficient for matrix2 items.</p> <code>0.0</code> <code>k</code> <code>int</code> <p>Number of top-k items per row to keep.</p> <code>100</code> <code>shrink</code> <code>float</code> <p>Shrinkage value that prevents instability when normalizations are small.</p> <code>0.0</code> <code>shrink_type</code> <code>Literal['stabilized', 'bayesian', 'additive']</code> <p>Type of shrinkage: 'stabilized', 'bayesian', 'additive'.</p> <code>'stabilized'</code> <code>threshold</code> <code>float</code> <p>Minimum similarity value to retain.</p> <code>0.0</code> <code>binary</code> <code>bool</code> <p>Whether to binarize the input matrix before computation.</p> <code>False</code> <code>target_rows</code> <code>Optional[Union[list[int], ndarray]]</code> <p>List or array of row indices to compute. If None, computes all.</p> <code>None</code> <code>target_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to include before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>filter_cols</code> <code>Optional[Union[list[int], ndarray, sparray]]</code> <p>Columns to exclude before top-k. Can be a list or sparse mask matrix.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to show a progress bar.</p> <code>True</code> <code>format_output</code> <code>Literal['csr', 'coo']</code> <p>Output format, either 'csr' or 'coo'. Use 'coo' on Windows.</p> <code>'coo'</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use (0 = all available cores).</p> <code>0</code> <code>block_size</code> <code>Optional[int]</code> <p>Block size for column-blocked accumulation (0=auto, None=disabled).</p> <code>0</code> <p>Returns:</p> Type Description <code>sparray</code> <p>A sparse matrix of top-k s_plus similarities in the specified format.</p> Source code in <code>similaripy/similarity.py</code> <pre><code>def s_plus(\n    matrix1: sparray,\n    matrix2: Optional[sparray] = None,\n    l1: float = 0.5,\n    l2: float = 0.5,\n    l3: float = 0.0,\n    t1: float = 1.0,\n    t2: float = 1.0,\n    c1: float = 0.5,\n    c2: float = 0.5,\n    pop1: Optional[Union[Literal['none','sum'], np.ndarray]]= 'none',\n    pop2: Optional[Union[Literal['none','sum'], np.ndarray]]= 'none',\n    alpha: float = 1.0,\n    beta1: float = 0.0,\n    beta2: float = 0.0,\n    k: int = 100,\n    shrink: float = 0.0,\n    shrink_type: Literal['stabilized', 'bayesian', 'additive'] = 'stabilized',\n    threshold: float = 0.0,\n    binary: bool = False,\n    target_rows: Optional[Union[list[int], np.ndarray]] = None,\n    target_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    filter_cols: Optional[Union[list[int], np.ndarray, sparray]] = None,\n    verbose: bool = True,\n    format_output: Literal['csr', 'coo'] = 'coo',\n    num_threads: int = 0,\n    block_size: Optional[int] = 0\n) -&gt; sparray:\n    \"\"\"\n    Combines Tversky and Cosine normalizations with RP3Beta-style depopularization, fully controlled by tunable weights\n\n    Args:\n        matrix1: Input sparse matrix.\n        matrix2: Optional second matrix. If None, uses matrix1.T.\n        l1: Tversky normalization strength.\n        l2: Cosine normalization strength.\n        l3: Popularity penalization strength.\n        t1: Tversky alpha for matrix1.\n        t2: Tversky beta for matrix2.\n        c1: Cosine exponent coefficient for matrix1.\n        c2: Cosine exponent coefficient for matrix2.\n        pop1: Popularity weights for matrix1. 'none', 'sum', or custom array.\n        pop2: Popularity weights for matrix2. 'none', 'sum', or custom array.\n        alpha: Coefficient applied on the raw similarity value before normalizations.\n        beta1: Popularity penalization coefficient for matrix1 items.\n        beta2: Popularity penalization coefficient for matrix2 items.\n        k: Number of top-k items per row to keep.\n        shrink: Shrinkage value that prevents instability when normalizations are small.\n        shrink_type: Type of shrinkage: 'stabilized', 'bayesian', 'additive'.\n        threshold: Minimum similarity value to retain.\n        binary: Whether to binarize the input matrix before computation.\n        target_rows: List or array of row indices to compute. If None, computes all.\n        target_cols: Columns to include before top-k. Can be a list or sparse mask matrix.\n        filter_cols: Columns to exclude before top-k. Can be a list or sparse mask matrix.\n        verbose: Whether to show a progress bar.\n        format_output: Output format, either 'csr' or 'coo'. Use 'coo' on Windows.\n        num_threads: Number of threads to use (0 = all available cores).\n        block_size: Block size for column-blocked accumulation (0=auto, None=disabled).\n\n    Returns:\n        A sparse matrix of top-k s_plus similarities in the specified format.\n    \"\"\"\n    stabilized_shrink, bayesian_shrink, additive_shrink = __get_shrink_values__(shrink, shrink_type)\n    return _sim.s_plus(\n        matrix1, matrix2=matrix2,\n        l1=l1, l2=l2, l3=l3,\n        t1=t1, t2=t2,\n        c1=c1, c2=c2,\n        a1=alpha,\n        weight_depop_matrix1=pop1,\n        weight_depop_matrix2=pop2,\n        p1=beta1,\n        p2=beta2,\n        k=k,\n        stabilized_shrink=stabilized_shrink,\n        bayesian_shrink=bayesian_shrink,\n        additive_shrink=additive_shrink,\n        threshold=threshold,\n        binary=binary,\n        target_rows=target_rows,\n        target_cols=target_cols,\n        filter_cols=filter_cols,\n        verbose=verbose,\n        format_output=format_output,\n        num_threads=num_threads,\n        block_size=block_size\n    )\n</code></pre>"}]}